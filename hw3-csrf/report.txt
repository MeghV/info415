Megh Vakharia
CSRF HW

Description
==========================================================
Cross-Site Request Forgery (CSRF) is an attack that 
causes an end user to unwittingly execute a request to
another page when they come to the attacker's page, 
causing unwanted actions. This is especially
bad if the request is made to a page that the end user
has already authenticated, essentially allowing the 
attacker to execute any request they want with the already
authenticated credentials of the end user, though the 
attacker needs to know the URL they are targeting for the 
request.

Test Steps
==========================================================
Level 3:
1) When you submit a post on the level 3 page, you'll realize
that the response always says "csrf token doesn't match". 
If you look at the HTML of the /make_post/3 page, note that a 
CSRF token is in fact present, meaning either the CSRF
token on the page is invalid and/or the server may not actually
care about the token to validate the request.

2) In BURP, you're able to change POST params before they're 
sent to the server. Utilize this:
Submit a post on /make_post/3 and when you see it in BURP, remove 
the value for the "csrf" param and Forward the
request. You'll get the same message - "csrf token doesn't match".

3) Now try submitting again, but this time remove the entire CSRF
value and param. You'll note that the server's response says:
"not authorized, you must be an admin to make a post". This means
that the client is always sending an invalid CSRF token (the page loads
with the invalid token), but if the "csrf" param isn't present, the
server will not check for it.

4) Create a webpage with a form that sends a POST request to 
"http://csrf-challenges.r7.io/make_post/3" on submission and include
only the "post" input - don't include the "csrf" input. If you submit
that form, you'lll realize that it was successful (or rather, it would
be successful on the admin's browser). As mentioned above, the server
will not check for a CSRF token if the param isn't present and will
allow your submission.

Level 4:
1) Unlike level 3, when you make a submission on level 4, you'll realize
that the CSRF token IS valid. This means that you will always need the CSRF
token generated by the server in the POST request to make a successful submission.
Simply adding a form on your webpage won't work. 

2) The way to solve this would be to put the /make_post/4 page in an iFrame so you're
able to still get access to the CSRF token and submit the page, but you're not
allowed to access the contents of an iFrame on a different domain. As such,
you need to use a page on "csrf-challenges.r7.io/" to create the iFrame.
Luckily, csrf-challenges.r7.io/xss exists!

3) If you go to "csrf-challenges.r7.io/xss?cc=EN" and track the response in BURP,
you'll see that the response header "X-XSS-Protection" comes back as 0, which means
XSS Protection doesn't exist on this page. A quick test by sending 
"cc=<script>alert(0)</script>" as the param will confirm this. Since this is on the
same domain, you're also able to access the contents of "csrf-challenges.r7.io/make_post/4"
on an iFrame.

4) You can pass the following payload to the cc param in the URL:
<iframe style="display: none" id="i" src="http://csrf-challenges.r7.io/make_post/4"></iframe> 
<script> 
document.getElementById('i').onload = function() { 
	var iframe = document.getElementById("i"),
		innerDoc = iframe.contentDocument || iframe.contentWindow.document,
		name = innerDoc.getElementsByName("post")[0].value = "meghv",
		token = innerDoc.getElementsByName("csrf")[0].value;
		console.log(token);
		innerDoc.getElementById("post_form").submit();
	} 
</script>
This will go within the iFrame, enter in the attacker's post value (in this case, "meghv"),
log the token on the /cc page (for debugging), and submit the form on /make_post/4. By using
XSS, you're ble to pass in any "post" value and automatically utilize the CSRF token on the page 
to make a successful POST to /make_post/4.

Mitigations
==========================================================
Django
To properly mitigate CSRF, you need to ensure that there is a valid
CSRF token on each form and that it's generate dynamically by the
server. It's easy to implement in Django - here's how:
1) Ensure that MIDDLEWARE_CLASSES contain the 'django.middleware.csrf.CsrfViewMiddleware'
module - this includes all of the code for CSRF protection.
2) In any template that uses a POST form, use the csrf_token tag inside the <form> element if the form is for an internal URL, e.g.: <form action="" method="post">{% csrf_token %}
3) In the corresponding view functions, ensure that RequestContext is used to render the response so that {% csrf_token %} will work properly. If youâ€™re using the render() function, generic views, or contrib apps, you are covered already since these all use RequestContext.

ASP.NET
1) You can use the "HtmlHelper.AntiForgeryToken" helper method to automatically
generate a CSRF token. 
2) Whenever you're adding a form, call the following code to automatically add
the hidden form field and set the cookie token:
@using (Html.BeginForm("Manage", "Account")) {
    @Html.AntiForgeryToken()
}

Further Reading / Reference:
http://www.asp.net/web-api/overview/security/preventing-cross-site-request-forgery-csrf-attacks
https://docs.djangoproject.com/ja/1.9/ref/settings/#std:setting-MIDDLEWARE_CLASSES
https://docs.djangoproject.com/es/1.9/topics/security/
https://docs.djangoproject.com/es/1.9/topics/security/#cross-site-request-forgery-csrf-protection
